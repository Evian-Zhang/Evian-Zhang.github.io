<!DOCTYPE doctype html>
<html>
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width initial-scale=1" name="viewport"/>
  <title>
   macOS上的汇编入门（九）——跳转与函数
  </title>
  <base target="_blank"/>
  <link href="/css/article.css" rel="stylesheet" type="text/css"/>
  <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
  <script type="text/x-mathjax-config">
   MathJax.Hub.Config({
tex2jax: {
	inlineMath: [ ['$','$'] ],
	displayMath: [ ['$$','$$'] ]
}
});
  </script>
 </head>
 <div id="main_wrapper">
  <header id="main_header">
   <a href="/index.html">
    Evian Zhang's
    <br/>
    naive blog
   </a>
   <h2>
    macOS上的汇编入门（九）——跳转与函数
   </h2>
  </header>  <div id="article_body">
   <p>
    <span>
     通过之前的几篇文章，我们了解了汇编语言的基本语法和变量的使用、寻址方式等，但我们的程序到目前为止，都只局限在
    </span>
    <code>
     _main
    </code>
    <span>
     内，既没有函数调用，也没有控制结构，进了
    </span>
    <code>
     _main
    </code>
    <span>
     以后一条路走到
    </span>
    <code>
     retq
    </code>
    <span>
     . 在这篇文章中，我主要介绍的是汇编语言中的控制结构——跳转，与函数调用。不过在介绍这两个之前，首先需要介绍的是跳转与函数调用的基础——标签。
    </span>
   </p>
   <h1>
    <a class="md-header-anchor" name="%E6%A0%87%E7%AD%BE">
    </a>
    <span>
     标签
    </span>
   </h1>
   <p>
    <span>
     标签(Label), 是汇编语言中一个重要的组成部分。我们之前在
    </span>
    <code>
     __DATA
    </code>
    <span>
     段
    </span>
    <code>
     __data
    </code>
    <span>
     节里定义变量的时候，就使用了标签。我们通常使用的标签，定义时是以冒号
    </span>
    <code>
     :
    </code>
    <span>
     结尾的一个标识符，且开头不能是数字。
    </span>
    <code>
     LBB0:
    </code>
    <span>
     ,
    </span>
    <code>
     a:
    </code>
    <span>
     ,
    </span>
    <code>
     _func:
    </code>
    <span>
     ,
    </span>
    <code>
     _main:
    </code>
    <span>
     都是标签的定义。
    </span>
   </p>
   <p>
    <span>
     我们可以在
    </span>
    <code>
     .data
    </code>
    <span>
     段，也可以在
    </span>
    <code>
     .text
    </code>
    <span>
     段定义标签，只需要在那里写上标签加上
    </span>
    <code>
     :
    </code>
    <span>
     即可。比如说，
    </span>
   </p>
   <pre><code class="language-assembly" lang="assembly">loop_begin:	movq	$0x114514, %rax
	jmp	loop_begin
</code></pre>
   <p>
    <span>
     就定义了一个标签
    </span>
    <code>
     loop_begin
    </code>
    <span>
     , 并且在下一条指令中使用了它. 接下来任何一个地方使用到
    </span>
    <code>
     loop_begin
    </code>
    <span>
     , 就代表这个指令所处的地址。
    </span>
   </p>
   <p>
    <span>
     一般来说，定义的标签只能在同一个汇编文件中使用，如果一个汇编文件想使用另一个汇编文件定义的标签，需要另一个汇编文件用
    </span>
    <code>
     .globl
    </code>
    <span>
     声明标签是全局可见的，比如说
    </span>
    <code>
     .globl	_main
    </code>
    <span>
     .
    </span>
   </p>
   <h1>
    <a class="md-header-anchor" name="%E8%B7%B3%E8%BD%AC">
    </a>
    <span>
     跳转
    </span>
   </h1>
   <p>
    <span>
     在介绍完标签之后，就可以解释跳转了。跳转分为无条件跳转与条件跳转。我们首先介绍无条件跳转。
    </span>
   </p>
   <h2>
    <a class="md-header-anchor" name="%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC">
    </a>
    <span>
     无条件跳转
    </span>
   </h2>
   <p>
    <span>
     无条件跳转对应的助记符是
    </span>
    <code>
     jmp
    </code>
    <span>
     . 其操作数是标签。
    </span>
    <code>
     jmp	loop_begin
    </code>
    <span>
     就是跳转到
    </span>
    <code>
     loop_begin
    </code>
    <span>
     标记的位置。这里就有一个问题，这样的跳转，是不是position indenpendent的呢？答案是是的。但是和之前PC-relative的技巧不同，这里PIC的方法不是程序员做的，而是汇编器做的。汇编器会直接将
    </span>
    <code>
     jmp
    </code>
    <span>
     翻译成相对跳转的机器码，对程序员来说是透明的。所以，我们并不需要太过关心这里的PIC.
    </span>
   </p>
   <p>
    <span>
     我们使用无条件跳转的时候要特别注意，因为极易造成死循环。比如说我们上面的那两行代码，就是死循环。
    </span>
   </p>
   <h2>
    <a class="md-header-anchor" name="%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC">
    </a>
    <span>
     条件跳转
    </span>
   </h2>
   <p>
    <span>
     相比于无条件跳转，我们更常用的是条件跳转。无条件跳转相当于C语言中的
    </span>
    <code>
     goto
    </code>
    <span>
     , 而条件跳转则是我们更常见的
    </span>
    <code>
     if
    </code>
    <span>
     ,
    </span>
    <code>
     while
    </code>
    <span>
     等控制语句。下面的例子给我们演示了条件跳转：
    </span>
   </p>
   <pre><code class="language-assembly" lang="assembly">	cmp	$0x114514, %rax
	je	loop_begin
</code></pre>
   <p>
    <code>
     cmp
    </code>
    <span>
     , 就是compare, 比较的意思。
    </span>
    <code>
     je
    </code>
    <span>
     中的
    </span>
    <code>
     e
    </code>
    <span>
     , 就是
    </span>
    <code>
     equate
    </code>
    <span>
     , 相等。我们可以大致理解一下这个的意思：如果
    </span>
    <code>
     %rax
    </code>
    <span>
     内的值与
    </span>
    <code>
     0x114514
    </code>
    <span>
     相等，那么就跳转到
    </span>
    <code>
     loop_begin
    </code>
    <span>
     这个标签处。那么，这是如何做到的呢？
    </span>
   </p>
   <p>
    <span>
     我们利用
    </span>
    <code>
     lldb
    </code>
    <span>
     查看在执行
    </span>
    <code>
     cmp	$0x114514, %rax
    </code>
    <span>
     之前和之后，寄存器的变化（关于
    </span>
    <code>
     lldb
    </code>
    <span>
     的使用我会在之后的文章中提到）。
    </span>
   </p>
   <p>
    <span>
     在执行
    </span>
    <code>
     cmp	$0x114514, %rax
    </code>
    <span>
     之前，寄存器的值为：
    </span>
   </p>
   <p>
    <img alt="before" referrerpolicy="no-referrer" src="macOS上的汇编入门（九）——跳转与函数.assets/before.png"/>
   </p>
   <p>
    <span>
     在执行
    </span>
    <code>
     cmp	$0x114514, %rax
    </code>
    <span>
     之后，寄存器的值为：
    </span>
   </p>
   <p>
    <img alt="after" referrerpolicy="no-referrer" src="macOS上的汇编入门（九）——跳转与函数.assets/after.png"/>
   </p>
   <p>
    <span>
     对比两张图，我们发现，除了存有当前指令地址的rip寄存器内的值发生了变化以外，还有一个寄存器的值发生了变化，那就是rflags. 这是什么寄存器呢？这又是根据什么变化的呢？
    </span>
   </p>
   <p>
    <span>
     这就是先行者们一个很妙的设计了。事实上，无论是
    </span>
    <code>
     cmp
    </code>
    <span>
     还是别的什么指令，其实大多数都有一个副作用——影响rflags寄存器。rflags寄存器，全称是状态标志寄存器。我们看它不能用十六进制看，要用二进制看。
    </span>
   </p>
   <p>
    <span>
     在执行
    </span>
    <code>
     cmp
    </code>
    <span>
     之前，rflags的值是
    </span>
    <code>
     0x246
    </code>
    <span>
     , 它的二进制表示是
    </span>
    <code>
     1001000110
    </code>
    <span>
     . 执行之后，rflags的值是
    </span>
    <code>
     0x287
    </code>
    <span>
     , 它的二进制表示是
    </span>
    <code>
     1010000111
    </code>
    <span>
     .
    </span>
   </p>
   <p>
    <span>
     这意味着什么呢？事实上，rflags中某些位是由特定的作用的。我们主要关注其低16位：
    </span>
   </p>
   <p>
    <img alt="rflags" referrerpolicy="no-referrer" src="macOS上的汇编入门（九）——跳转与函数.assets/rflags.png"/>
   </p>
   <p>
    <span>
     每一个以F结尾的都代表一个flag, 比如说CF就是carry flag, 是否进位。而我们的
    </span>
    <code>
     cmp
    </code>
    <span>
     指令，若两数相等，则会把ZF位置
    </span>
    <code>
     1
    </code>
    <span>
     ，否则置
    </span>
    <code>
     0
    </code>
    <span>
     . 而
    </span>
    <code>
     je
    </code>
    <span>
     指令，则是当ZF位为
    </span>
    <code>
     1
    </code>
    <span>
     时再跳转，否则什么事也不做。
    </span>
   </p>
   <p>
    <span>
     那么一个指令究竟会影响多少位呢，这个在指令集(
    </span>
    <a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf">
     <span>
      64-ia-32-architectures-software-developer-instruction-set-reference-manual
     </span>
    </a>
    <span>
     )中会有详细说明，这里不再赘述。只强调一点，在做运算时，往往都会涉及标志位的改变。结果是否为零、是否进位、是否溢出等等，都是决定各个标志位的因素。
    </span>
   </p>
   <p>
    <span>
     而依据不同的标志位，有不同的条件跳转指令。比如说，依据ZF, 有
    </span>
    <code>
     je
    </code>
    <span>
     （ZF=
    </span>
    <code>
     1
    </code>
    <span>
     时跳转），
    </span>
    <code>
     jne
    </code>
    <span>
     （ZF=
    </span>
    <code>
     0
    </code>
    <span>
     时跳转）；依据CF, 有
    </span>
    <code>
     jc
    </code>
    <span>
     （CF=
    </span>
    <code>
     1
    </code>
    <span>
     时跳转），
    </span>
    <code>
     jnc
    </code>
    <span>
     （CF=
    </span>
    <code>
     0
    </code>
    <span>
     时跳转）。此外，还有依据多个标志位的跳转指令。但是，我们实际上并不太需要记得跳转指令对应的标志位情况，我们需要记住的是跳转指令对应的逻辑情况，比如说，
    </span>
    <code>
     je
    </code>
    <span>
     代表相等时跳转，
    </span>
    <code>
     jne
    </code>
    <span>
     代表不相等时跳转；
    </span>
    <code>
     jg
    </code>
    <span>
     代表大于时跳转，
    </span>
    <code>
     jge
    </code>
    <span>
     代表大于等于时跳转；
    </span>
    <code>
     jl
    </code>
    <span>
     代表小于时跳转，
    </span>
    <code>
     jle
    </code>
    <span>
     代表小于等于时跳转。这里还要强调一下，“大于”、“小于”究竟是谁大谁小。在我们
    </span>
    <code>
     cmp	a, b
    </code>
    <span>
     时，实际上执行的是
    </span>
    <code>
     b
    </code>
    <span>
     -
    </span>
    <code>
     a
    </code>
    <span>
     , 比较的是
    </span>
    <code>
     b
    </code>
    <span>
     和
    </span>
    <code>
     a
    </code>
    <span>
     .
    </span>
    <code>
     b
    </code>
    <span>
     &gt;
    </span>
    <code>
     a
    </code>
    <span>
     ，会是
    </span>
    <code>
     jg
    </code>
    <span>
     的跳转，而
    </span>
    <code>
     b
    </code>
    <span>
     &lt;
    </span>
    <code>
     a
    </code>
    <span>
     会是
    </span>
    <code>
     jl
    </code>
    <span>
     的跳转。
    </span>
   </p>
   <p>
    <span>
     此外，我们还需要记得大部分非跳转指令对应的标志位的改变。比如说，
    </span>
    <code>
     add
    </code>
    <span>
     指令涉及的标志位就有OF, SF, ZF, AF, CF和PF.
    </span>
   </p>
   <h1>
    <a class="md-header-anchor" name="%E5%87%BD%E6%95%B0">
    </a>
    <span>
     函数
    </span>
   </h1>
   <p>
    <span>
     大略地讲完了跳转之后，就涉及到了函数。我们知道，在跳转时，有一个特点，那就是跳转了就回不来了。除非我们在跳转指令之后再加上一个标签，然后在跳转去的部分中找到合适的位置跳转回来。这是比较麻烦的。所以，跳转指令一般指适用在控制语句中，并不会用于函数的调用。当我们进行函数调用时，应该使用全新的指令——
    </span>
    <code>
     call
    </code>
    <span>
     和
    </span>
    <code>
     ret
    </code>
    <span>
     .
    </span>
   </p>
   <p>
    <code>
     call
    </code>
    <span>
     指令和
    </span>
    <code>
     jmp
    </code>
    <span>
     指令一样，接受一个标签作为操作数，直观上看和
    </span>
    <code>
     jmp
    </code>
    <span>
     的效果也类似，直接跳转到该标签所在的指令。但是，
    </span>
    <code>
     call
    </code>
    <span>
     指令还干了一件事——把当前的rip寄存器
    </span>
    <code>
     push
    </code>
    <span>
     到栈区里。这实际上和我们利用
    </span>
    <code>
     jmp
    </code>
    <span>
     解决跳出去回不来的问题的方法类似，把返回的地址放到栈上。然后，
    </span>
    <code>
     call
    </code>
    <span>
     就没事儿了。
    </span>
   </p>
   <p>
    <span>
     在我们执行完函数的运算之后，想要返回之前调用函数的地方，这该怎么办呢？就用到了
    </span>
    <code>
     ret
    </code>
    <span>
     .
    </span>
    <code>
     ret
    </code>
    <span>
     无操作数，默认当前栈顶，也就是rsp指向的位置，存储的是当初
    </span>
    <code>
     call
    </code>
    <span>
     时
    </span>
    <code>
     push
    </code>
    <span>
     到栈区的地址，然后直接跳转，并且把那个地址弹栈。因此，在之前提到局部变量的时候，我们在最后恢复了rsp, 让其还是指向最初的位置，目的就是这个。
    </span>
   </p>
   <p>
    <code>
     call
    </code>
    <span>
     和
    </span>
    <code>
     ret
    </code>
    <span>
     都可以加上一个
    </span>
    <code>
     q
    </code>
    <span>
     ，形成
    </span>
    <code>
     callq
    </code>
    <span>
     和
    </span>
    <code>
     retq
    </code>
    <span>
     . 这和
    </span>
    <code>
     call
    </code>
    <span>
     和
    </span>
    <code>
     ret
    </code>
    <span>
     实际上是没有区别的，只是强调那个地址是8个字节的地址。
    </span>
   </p>
   <h1>
    <a class="md-header-anchor" name="%E6%80%BB%E7%BB%93">
    </a>
    <span>
     总结
    </span>
   </h1>
   <p>
    <span>
     我们来看一个迭代法计算大于3的数对应的Fibonacci数列的简单的程序：
    </span>
   </p>
   <pre><code class="language-assembly" lang="assembly"># Fibonacci.s
    .text
    .globl  _main
_main:
    movq    $13, %rdi
    callq   _Fibonacci
    retq

_Fibonacci:
    movq    $1, %rax
    movq    $1, %rbx
compare:
    cmp $2, %rdi
    jg loop_continue
    retq
loop_continue:
    movq    %rax, %rcx
    addq    %rbx, %rax
    movq    %rcx, %rbx
    decq %rdi
    jmp compare
</code></pre>
   <p>
    <span>
     这个简单的程序计算了第13项斐波那契数列，并且也用到了这篇文章中所讲的跳转与函数。大家可以仔细研究这个程序。
    </span>
   </p>
   <p>
    <span>
     我们在命令行中键入
    </span>
   </p>
   <pre><code class="language-shell" lang="shell">as Fibonacci.s -o Fibonacci.o
</code></pre>
   <p>
    <span>
     进行汇编，再键入
    </span>
   </p>
   <pre><code class="language-shell" lang="shell">ld Fibonacci.o -o Fibonacci -lSystem
</code></pre>
   <p>
    <span>
     进行链接。并使用
    </span>
   </p>
   <pre><code class="language-shell" lang="shell">./Fibonacci
</code></pre>
   <p>
    <span>
     来执行函数，最后用
    </span>
   </p>
   <pre><code class="language-shell" lang="shell">echo $?
</code></pre>
   <p>
    <span>
     来查看结果。最终结果如下：
    </span>
   </p>
   <p>
    <img alt="result" referrerpolicy="no-referrer" src="macOS上的汇编入门（九）——跳转与函数.assets/result.png"/>
   </p>
   <p>
    <span>
     结果正确。
    </span>
   </p>
   <p>
    <span>
     至于这个程序中为什么采用rdi进行参数传递，以及rax作为返回值，还有一些不足和缺陷，我会在下篇文章中提到。
    </span>
   </p>
   <h1>
    <a class="md-header-anchor" name="%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%93%AA%E7%9C%8B%E5%88%B0%E8%BF%99%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0">
    </a>
    <span>
     可以在哪看到这系列文章
    </span>
   </h1>
   <p>
    <span>
     我在我的
    </span>
    <a href="https://github.com/Evian-Zhang/Assembly-on-macOS">
     <span>
      GitHub
     </span>
    </a>
    <span>
     上，
    </span>
    <a href="https://zhuanlan.zhihu.com/c_1132336120712765440">
     <span>
      知乎专栏
     </span>
    </a>
    <span>
     上和
    </span>
    <a href="https://blog.csdn.net/EvianZhang">
     <span>
      CSDN
     </span>
    </a>
    <span>
     上同步更新。
    </span>
   </p>
   <p>
    <span>
     上一篇文章：
    </span>
    <a href="macOS上的汇编入门（八）——寻址方式与全局变量.html">
     <span>
      macOS上的汇编入门（八）——寻址方式与全局变量
     </span>
    </a>
   </p>
  <p>
    <span>
     下一篇文章：
    </span>
   <a href="macOS上的汇编入门（十）——再探函数.html">
     <span>
      macOS上的汇编入门（十）——再探函数
     </span>
   </a>
  </p>
  </div>
 </div>
</html>